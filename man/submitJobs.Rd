% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/submitJobs.R
\name{submitJobs}
\alias{submitJobs}
\title{Submit Jobs to the Batch Systems}
\usage{
submitJobs(ids = NULL, resources = list(), reg = getDefaultRegistry())
}
\arguments{
\item{ids}{[\code{\link[base]{data.frame}} or \code{integer}]\cr
A \code{\link[base]{data.frame}} (or \code{\link[data.table]{data.table}})
with a column named \dQuote{job.id}.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of \code{\link{findNotSubmitted}}.}

\item{resources}{[\code{named list}]\cr
Computational  resources for the batch jobs. The elements of this list
(e.g. something like \dQuote{walltime} or \dQuote{nodes}) depend on your template file.
See notes for reserved special resource names.
Defaults can be set in the \code{\link{Registry}} via the variable \code{default.resources} as a named list.
The setting can be made permanent for all future registries by setting this variable in your configuration file.
Individual settings set via \code{resources} \code{resources} overrule those in \code{default.resources}.}

\item{reg}{[\code{\link{Registry}}]\cr
Registry. If not explicitly passed, uses the last created registry.}
}
\value{
[\code{\link{data.table}}]. Table with columns \dQuote{job.id} and \dQuote{chunk}.
  See \code{\link{JoinTables}} for examples on working with job tables.
}
\description{
Submits all jobs defined with \code{\link{batchMap}} to the batch system.

If an additional column \dQuote{chunk} is present in the table \code{ids},
the jobs will be grouped accordingly. See \code{\link{chunkIds}} for more
information.

After submitting the jobs, you can use \code{\link{waitForJobs}} to wait for the
termination of jobs or immediately call \code{\link{reduceResultsList}}/\code{\link{reduceResults}}
to collect partial results.
The progress can be monitored with \code{\link{getJobStatus}}.
}
\note{
Setting \code{measure.memory} to \code{TRUE} turns on memory measurement: \code{\link[base]{gc}} is called  directly before
and after the job and the difference is stored in the internal database. Note that this is just a rough estimate and does
neither work reliably for external code like C/C++ nor in combination with threading.

Furthermore, the package provides support for inner parallelization using threading, sockets or MPI via the
package \pkg{parallelMap}.
If you set the resource \dQuote{pm.backend} to \dQuote{multicore}, \dQuote{socket} or \dQuote{mpi},
\code{\link[parallelMap]{parallelStart}} is called on the slave before the first job in the chunk is started
and \code{\link[parallelMap]{parallelStop}} is called after the last job terminated.
This way, the used resources for inner parallelization are set in the same place as the resources for the outer parallelization and
get automatically stored in the \code{\link{Registry}}.
The user function just has to call \code{\link[parallelMap]{parallelMap}} to start parallelization to use the configured backend.

You may set the resource \code{ncpus} to control the number of CPUs to use in \pkg{parallelMap}.
\code{ncpus} defaults to the number of available CPUs (as reported by (see \code{\link[parallel]{detectCores}}))
on the executing machine for multicore and socket mode and defaults to the return value of \code{\link[Rmpi]{mpi.universe.size}-1} for MPI.
Furthermore, you can set the \code{level} for \code{\link[parallelMap]{parallelMap}} via \dQuote{pm.level}.

Note that your template must be set up to handle the parallelization, e.g. start R with \code{mpirun} or request the correct number of CPUs.
}

