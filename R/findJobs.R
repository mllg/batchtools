#' @export
#' @rdname findJobs
findSubmitted = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findSubmitted(reg, ids)
}

.findSubmitted = function(reg, ids = NULL) {
  submitted = NULL
  filter(reg$status, ids)[!is.na(submitted), "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findNotSubmitted = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findNotSubmitted(reg, ids)
}

.findNotSubmitted = function(reg, ids = NULL) {
  submitted = NULL
  filter(reg$status, ids)[is.na(submitted), "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findStarted = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findStarted(reg, ids)
}

.findStarted = function(reg, ids = NULL) {
  started = NULL
  filter(reg$status, ids)[!is.na(started), "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findNotStarted = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findNotStarted(reg, ids)
}

.findNotStarted = function(reg, ids = NULL) {
  started = NULL
  filter(reg$status, ids)[is.na(started), "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findDone = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findDone(reg, ids)
}

.findDone = function(reg, ids = NULL) {
  done = error = NULL
  filter(reg$status, ids)[!is.na(done) & is.na(error), "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findNotDone = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findNotDone(reg, ids)
}

.findNotDone = function(reg, ids = NULL) {
  done = error = NULL
  filter(reg$status, ids)[is.na(done) | !is.na(error), "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findErrors = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findErrors(reg, ids)
}

.findErrors = function(reg, ids = NULL) {
  error = NULL
  filter(reg$status, ids)[!is.na(error), "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findOnSystem = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findOnSystem(reg, ids)
}

.findOnSystem = function(reg, ids = NULL, status = "all", batch.ids = getBatchIds(reg, status = status)) {
  if (length(batch.ids) == 0L)
    return(data.table(job.id = integer(0L), key = "job.id"))
  submitted = done = batch.id = NULL
  filter(reg$status, ids)[!is.na(submitted) & is.na(done) & batch.id %in% batch.ids$batch.id, "job.id", with = FALSE]
}


#' @export
#' @rdname findJobs
findRunning = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findOnSystem(reg, ids, batch.ids = getBatchIds(reg, status = "running"))
}

#' @export
#' @rdname findJobs
findQueued = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findOnSystem(reg, ids, batch.ids = getBatchIds(reg, status = "queued"))
}


#' @export
#' @rdname findJobs
findExpired = function(ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  .findExpired(reg, ids)
}

.findExpired = function(reg, ids = NULL, batch.ids = getBatchIds(reg)) {
  submitted = done = batch.id = NULL
  filter(reg$status, ids)[!is.na(submitted) & is.na(done) & batch.id %nin% batch.ids$batch.id, "job.id", with = FALSE]
}


#' @title Find and Filter Jobs
#'
#' @description
#' Use \code{findJobs} to query jobs for which a predicate expression, evaluated on the parameters, yields \code{TRUE}.
#' The other functions can be used to query the computational status.
#' Note that they do not synchronize the registry, thus you are advised to run \code{\link{syncRegistry}} yourself
#' or, if you are really just interested in the status, use \code{\link{getStatus}}.
#' Note that \code{findOnSystem} and \code{findExpired} are somewhat heuristic and may report misleading results, depending on the state of the system.
#'
#' @param expr [\code{expression}]\cr
#'   Predicate expression evaluated in the job parameters.
#' @templateVar ids.default all
#' @template ids
#' @template reg
#' @return [\code{\link{data.table}}]. Matching job ids are stored in the column \dQuote{job.id}.
#'   See \code{\link{JoinTables}} for examples on working with job tables.
#' @export
#' @examples
#' reg = makeRegistry(file.dir = NA, make.default = FALSE)
#' batchMap(identity, i = 1:3, reg = reg)
#' ids = findNotSubmitted(reg = reg)
#'
#' # get all jobs:
#' findJobs(reg = reg)
#'
#' # filter for jobs with parameter i >= 2
#' findJobs(i >= 2, reg = reg)
#'
#' # filter on the computational status
#' findSubmitted(reg = reg)
#' findNotDone(reg = reg)
findJobs = function(expr, ids = NULL, reg = getDefaultRegistry()) {
  assertRegistry(reg, sync = TRUE)
  if (missing(expr))
    return(filter(reg$status, ids)[, "job.id", with = FALSE])

  expr = substitute(expr)
  ee = parent.frame()
  fun = function(pars) eval(expr, pars, enclos = ee)
  pars = NULL
  setkeyv(inner_join(reg$defs, filter(reg$status, ids))[vlapply(pars, fun), "job.id", with = FALSE], "job.id")[]
}


#' @export
#' @rdname findJobs
#' @param prob.name [\code{character}]\cr
#'   Whitelist of problem names.
#'   If the string starts with \dQuote{~}, it is treated as regular expression.
#'   If not provided, all problems are matched.
#' @param algo.name [\code{character}]\cr
#'   Whitelist of algorithm names.
#'   If the string starts with \dQuote{~}, it is treated as regular expression.
#'   If not provided, all algorithms are matched.
#' @param prob.pars [\code{expression}]\cr
#'   Predicate expression evaluated in the problem parameters.
#' @param algo.pars [\code{expression}]\cr
#'   Predicate expression evaluated in the algorithm parameters.
#' @param repls [\code{integer}]\cr
#'   Whitelist of replication numbers. If not provided, all replications are matched.
findExperiments = function(prob.name = NULL, algo.name = NULL, prob.pars, algo.pars, repls = NULL, ids = NULL, reg = getDefaultRegistry()) {
  strmatch = function(x, pattern) {
    y = split(pattern, ifelse(stri_startswith_fixed(pattern, "~"), "regex", "table"))
    for (p in y$regex)
      y$table = union(y$table, stri_subset_regex(levels(x), stri_sub(p, 2L)))
    x %in% y$table
  }

  assertExperimentRegistry(reg, sync = TRUE)
  ee = parent.frame()
  tab = inner_join(reg$defs, filter(reg$status, ids))[, c("job.id", "pars", "problem", "algorithm", "repl"), with = FALSE]

  if (!is.null(prob.name)) {
    assertCharacter(prob.name, any.missing = FALSE, min.chars = 1L)
    problem = NULL
    tab = tab[strmatch(problem, prob.name)]
  }

  if (!is.null(algo.name)) {
    assertCharacter(algo.name, any.missing = FALSE, min.chars = 1L)
    algorithm = NULL
    tab = tab[strmatch(algorithm, algo.name)]
  }

  if (!missing(prob.pars)) {
    expr = substitute(prob.pars)
    fun = function(pars) eval(expr, pars$prob.pars, enclos = ee)
    pars = NULL
    tab = tab[vlapply(pars, fun)]
  }

  if (!missing(algo.pars)) {
    expr = substitute(algo.pars)
    fun = function(pars) eval(expr, pars$algo.pars, enclos = ee)
    pars = NULL
    tab = tab[vlapply(pars, fun)]
  }

  if (!is.null(repls)) {
    repls = asInteger(repls, any.missing = FALSE)
    repl = NULL
    tab = tab[repl %in% repls]
  }

  setkeyv(tab[, "job.id", with = FALSE], "job.id")[]
}
